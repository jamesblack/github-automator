{
  "name": "startup",
  "version": "0.3.0",
  "description": "Node.js HTTP app runner",
  "scripts": {
    "test": "./node_modules/.bin/mocha"
  },
  "bin": {
    "startup": "bin/startup"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/CamShaft/startup.git"
  },
  "keywords": [
    "app",
    "runner",
    "cluster",
    "express",
    "connect",
    "http",
    "development"
  ],
  "author": {
    "name": "Cameron Bytheway",
    "email": "cameron@nujii.com"
  },
  "license": "MIT",
  "readmeFilename": "README.md",
  "engines": {
    "node": ">=0.8.x"
  },
  "dependencies": {
    "commander": "~1.1.1",
    "cli-table": "~0.2.0",
    "node-uuid": "~1.4.0",
    "win-fork": "~1.1.1",
    "node-dev": "~2.0.1",
    "toobusy": "~0.2.3",
    "envs": "~0.1.3"
  },
  "devDependencies": {
    "should": "~1.2.1",
    "mocha": "~1.8.1",
    "express": "~3.1.0",
    "connect": "~2.7.2",
    "ejs": "~0.8.3"
  },
  "readme": "startup\n=======\n\nNode.js HTTP app runner\n\nFeatures\n--------\n\n* [Port Binding](#port-binding)\n* [Hot-Reloading](#hot-reload)\n* [Domains](#domains)\n* [Cluster](#cluster)\n* [SIGTERM and SIGINT handling](#sigterm-and-sigint)\n\nUsage\n-----\n\nAll startup requires is an exported http app:\n\n### Express Example\n```js\nvar express = require(\"express\");\n\n// Export the express app\nvar app = module.exports = express();\n\napp.get(\"/\", function (req, res){\n  res.send(\"Hello!\");\n});\n```\n\n### Connect Example\n```js\nvar connect = require(\"connect\");\n\n// Export the connect app\nvar app = module.exports = connect();\n\napp.use(function (req, res, next){\n  res.send(\"Hello!\");\n});\n```\n\n### Vanilla HTTP Example\n```js\nvar http = require(\"http\");\n\n// Create the http server\nvar server = http.createServer(function (req, res){\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.end(\"Hello!\");\n});\n\n// Export it\nmodule.exports = server;\n```\n\nTo start the app, just run:\n\n```sh\nstartup start\n```\n\nand startup will bind to the `PORT` environment variable.\n\n### Sockjs Example\n\nTo install any handlers needed, sockjs for example, listen for the `ready` event:\n\n```js\nvar express = require(\"express\")\n  , sockjs = require(\"sockjs\");\n\n// Export the express app\nvar app = module.exports = express();\n\n// Setup the sockjs server\nvar echo = sockjs.createServer();\necho.on('connection', function(conn) {\n  conn.on('data', function(message) {\n    conn.write(message);\n  });\n  conn.on('close', function() {});\n});\n\napp.get(\"/\", function (req, res){\n  res.send(\"Hello!\");\n});\n\n// Install the handlers\napp.on(\"ready\", function(server){\n  echo.installHandlers(server, {prefix: \"/echo\"});\n});\n```\n\n### Listening Callback\n\nTo know when the server is listening on a port, bind to the `listening` event:\n\n```js\nvar express = require(\"express\");\n\n// Export the express app\nvar app = module.exports = express();\n\napp.get(\"/\", function (req, res){\n  res.send(\"Hello!\");\n});\n\napp.on(\"listening\", function(server){\n  console.log(\"My app is listening\");\n});\n```\n\n\nCommands\n--------\n\n###`startup start`\n\nStarts app listening on the `PORT` environment variable.\n\n###`startup middleware`\n\nLists loaded middleware (express and connect only) without running the app.\n\n###`startup routes`\n\nLists loaded middleware (express only) without running the app.\n\n###`startup settings`\n\nLists app settings (express only) without running the app.\n\nPort Binding\n------------\n\n`startup` will look for the `PORT` environment variable and try to bind to it. If not value is found, it defaults to `3000`. You can also set it by executing `startup start -P <port>`.\n\nHot-Reload\n----------\n\nTo enable hot-reload, set the `NODE_ENV` environment variable to `development`. You may also specify --dev to force it.\n\nRead more about [node-dev](https://github.com/fgnass/node-dev), the tool `startup` uses.\n\nDomains\n-------\n\n[Domains](http://nodejs.org/api/domain.html) were introducted in `v0.8` and act as a way to isolate uncaught exceptions in a process. This proves useful for http servers when we want each request to be handled in a unique domain, as to not crash the whole server.\n\nSetting it up requires a bit of boilerplate code that comes built in to `startup`.\n\nYou can also provide a custom error handler for when you do get an uncaught exception by exporting `errorHandler` in your app:\n\n```js\nvar express = require(\"express\");\n\n// Export the express app\nvar app = module.exports = express();\n\napp.get(\"/\", function (req, res){\n  res.send(\"Hello!\")\n});\n\nmodule.exports.errorHandler = function (err, req, res) {\n  res.send(\"There was an error!\");\n};\n```\n\nCluster\n-------\n\n[Cluster](http://nodejs.org/api/cluster.html) allows a server to take advantage of all of the cores on a system instead of being limited by node's single thread. Cluster mode is enabled by default in production.\n\n\nSIGTERM and SIGINT\n------------------\n\n`startup` reacts to system messages to enable clean exits. When it receives a SIGTERM it stops accepting connections and gives all of the current connections 3 seconds (overridable by setting SOCKET_TIMEOUT) to clean up and shut down. In environments like heroku it is very important the server reacts to these messages since the platform can shut it down at any time.\n",
  "_id": "startup@0.3.0",
  "_from": "startup@*"
}
